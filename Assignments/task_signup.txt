Phase 1

  Compress image
  +-------+    +-----------+    +----------+    +--------+    +------------+
  | Image | -> | Wavelet   | -> | Quantize | -> | Encode | -> | Compressed |
  +-------+    | transform |    +----------+    +--------+    | Image      |
               +-----------+                                  +------------+


  Decompress image
  +------------+    +--------+    +-------------+    +-----------+    +-----------------+
  | Compressed | -> | Decode | -> | Approximate | -> | Inverse   | -> | Round off to    |
  | Image      |    +--------+    | wavelet     |    | wavelet   |    | integer values, |
  +------------+                  | transform   |    | transform |    | create image    |
                                  +-------------+    +-----------+    +-----------------+

 
  For phase 1:
    Work with square tiles.
    Use Haar wavelet.
    Quantization: uniform, or logarithmic, or Lloyd's algorithm?
    File format: use our own (not JPEG 2000)
    Compare performance of CPU vs. GPU
    Report error of reconstruction

  Parameters that will need to be in the file header:
    size of tile
    number of wavelet steps
    threshold cutoff
    quantization bit count

  Task list

  Who       Task                      Status
  ---       ----                      ------
  Ed        Haar wavelet transform    Working
  Ed        Inverse Haar              Working
  David     Call CUDA from Octave     Working
  Bonnie    Threshold                 CPU working, GPU in progress
  Bonnie    Quantizaion, uniform      CPU working, GPU in progress
              & log
  Bonnie    De-quantization,          In progress
              uniform & log
  Ed        Run length codec          CPU working, GPU in progress
  Ed        File I/O                  In progress
  Ed        Compare CPU
  -         Compare original with      
              reconstructed image
  -         Write abstract

Overall goals (not really indepenent tasks)
 - Document all interfaces (via Doxygen)
 - Implement each component on CPU as well as GPU, and be able demonstrate
 - Demonstrate difference between CPU performance and GPU performance
 - Runtime options:
     select forward (compress) or reverse (decompress)
     size of tile
     number of wavelet steps
     threshold cutoff
     quantization bit count
     quantization method
 - Write unit test for each component (recommend building them while the
   component is being written).
 - Write integration tests.

I'm leaving out "compare CPU and GPU" as a task, since each component
should do that for itself. 
